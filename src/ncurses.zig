const c = @import("c.zig");

//====================================================================
// Types
//====================================================================

pub const chtype = c_uint;
pub const mmask_t = c_uint;
pub const attr_t = chtype;

const Err = c.ERR; // -1
const Ok = c.OK; // 0
const True = c.TRUE; // 1
const False = c.FALSE; // 0

pub const cchar_t = extern struct {
    attr: attr_t,
    chars: [CCHARW_MAX]wchar_t,
};

pub const NcursesError = error{
    Generic,
};

//====================================================================
// Enums
//====================================================================

// zig fmt: off
pub const Color = extern enum(c_short) {
    black   = 0,
    red     = 1,
    green   = 2,
    yellow  = 3,
    blue    = 4,
    magenta = 5,
    cyan    = 6,
    white   = 7,
};
// zig fmt: on

// zig fmt: off
pub const Key = extern enum(c_int) {
    //  Pseudo-character tokens outside ASCII range.  The curses wgetch() function
    //  will return any given one of these only if the corresponding k- capability
    //  is defined in your terminal's terminfo entry.
    //
    //  Some keys (KEY_A1, etc) are arranged like this:
    //     a1     up    a3
    //     left   b2    right
    //     c1     down  c3
    //
    //  A few key codes do not depend upon the terminfo entry.

    code_yes   = 0o400, // A wchar_t contains a key code
    min        = 0o401, // Minimum curses key
    @"break"   = 0o401, // Break key (unreliable)
    sreset     = 0o530, // Soft (partial) reset (unreliable)
    reset      = 0o531, // Reset or hard reset (unreliable)

    // These definitions were generated by ./MKkey_defs.sh ./Caps ./Caps-ncurses
    down       = 0o402, // down-arrow key
    up         = 0o403, // up-arrow key
    left       = 0o404, // left-arrow key
    right      = 0o405, // right-arrow key
    home       = 0o406, // home key
    backspace  = 0o407, // backspace key
    f0         = 0o410, // Function keys.  Space for 64
    f1         = 0o411,
    f2         = 0o412,
    f3         = 0o413,
    f4         = 0o414,
    f5         = 0o415,
    f6         = 0o416,
    f7         = 0o417,
    f8         = 0o420,
    f9         = 0o421,
    f10        = 0o422,
    f11        = 0o423,
    f12        = 0o424,
    dl         = 0o510, // delete-line key
    il         = 0o511, // insert-line key
    dc         = 0o512, // delete-character key
    ic         = 0o513, // insert-character key
    eic        = 0o514, // sent by rmir or smir in insert mode
    clear      = 0o515, // clear-screen or erase key
    eos        = 0o516, // clear-to-end-of-screen key
    eol        = 0o517, // clear-to-end-of-line key
    sf         = 0o520, // scroll-forward key
    sr         = 0o521, // scroll-backward key
    npage      = 0o522, // next-page key
    ppage      = 0o523, // previous-page key
    stab       = 0o524, // set-tab key
    ctab       = 0o525, // clear-tab key
    catab      = 0o526, // clear-all-tabs key
    enter      = 0o527, // enter/send key
    print      = 0o532, // print key
    ll         = 0o533, // lower-left key (home down)
    a1         = 0o534, // upper left of keypad
    a3         = 0o535, // upper right of keypad
    b2         = 0o536, // center of keypad
    c1         = 0o537, // lower left of keypad
    c3         = 0o540, // lower right of keypad
    btab       = 0o541, // back-tab key
    beg        = 0o542, // begin key
    cancel     = 0o543, // cancel key
    close      = 0o544, // close key
    command    = 0o545, // command key
    copy       = 0o546, // copy key
    create     = 0o547, // create key
    end        = 0o550, // end key
    exit       = 0o551, // exit key
    find       = 0o552, // find key
    help       = 0o553, // help key
    mark       = 0o554, // mark key
    message    = 0o555, // message key
    move       = 0o556, // move key
    next       = 0o557, // next key
    open       = 0o560, // open key
    options    = 0o561, // options key
    previous   = 0o562, // previous key
    redo       = 0o563, // redo key
    reference  = 0o564, // reference key
    refresh    = 0o565, // refresh key
    replace    = 0o566, // replace key
    restart    = 0o567, // restart key
    @"resume"  = 0o570, // resume key
    save       = 0o571, // save key
    sbeg       = 0o572, // shifted begin key
    scancel    = 0o573, // shifted cancel key
    scommand   = 0o574, // shifted command key
    scopy      = 0o575, // shifted copy key
    screate    = 0o576, // shifted create key
    sdc        = 0o577, // shifted delete-character key
    sdl        = 0o600, // shifted delete-line key
    select     = 0o601, // select key
    send       = 0o602, // shifted end key
    seol       = 0o603, // shifted clear-to-end-of-line key
    sexit      = 0o604, // shifted exit key
    sfind      = 0o605, // shifted find key
    shelp      = 0o606, // shifted help key
    shome      = 0o607, // shifted home key
    sic        = 0o610, // shifted insert-character key
    sleft      = 0o611, // shifted left-arrow key
    smessage   = 0o612, // shifted message key
    smove      = 0o613, // shifted move key
    snext      = 0o614, // shifted next key
    soptions   = 0o615, // shifted options key
    sprevious  = 0o616, // shifted previous key
    sprint     = 0o617, // shifted print key
    sredo      = 0o620, // shifted redo key
    sreplace   = 0o621, // shifted replace key
    sright     = 0o622, // shifted right-arrow key
    srsume     = 0o623, // shifted resume key
    ssave      = 0o624, // shifted save key
    ssuspend   = 0o625, // shifted suspend key
    sundo      = 0o626, // shifted undo key
    @"suspend" = 0o627, // suspend key
    undo       = 0o630, // undo key
    mouse      = 0o631, // Mouse event has occurred
    resize     = 0o632, // Terminal resize event
    event      = 0o633, // We were interrupted by an event
    max        = 0o777, // Maximum key value is 0633

    _,                  // Any other key
};
// zig fmt: on

// zig fmt: off
pub const Attribute = extern enum(u32) {
    fn ncursesBits(mask: u32, shift: u5) u32 {
        const default_shift: u5 = 8;
        return mask << default_shift + shift;
    }

    normal     = 0,
    attributes = ncursesBits(1, 0),
    chartext   = ncursesBits(1, 0) - 1,
    color      = ncursesBits((1 << 8) - 1, 0),
    standout   = ncursesBits(1, 8),
    underline  = ncursesBits(1, 9),
    reverse    = ncursesBits(1, 10),
    blink      = ncursesBits(1, 11),
    dim        = ncursesBits(1, 12),
    bold       = ncursesBits(1, 13),
    altcharset = ncursesBits(1, 14),
    invis      = ncursesBits(1, 15),
    protect    = ncursesBits(1, 16),
    horizontal = ncursesBits(1, 17),
    left       = ncursesBits(1, 18),
    low        = ncursesBits(1, 19),
    right      = ncursesBits(1, 20),
    top        = ncursesBits(1, 21),
    vertical   = ncursesBits(1, 22),
    italic     = ncursesBits(1, 23),
};
// zig fmt: on

//====================================================================
// Globals
//====================================================================

pub extern "ncurses" var curscr: *c._win_st;
pub extern "ncurses" var newscr: *c._win_st;
pub extern "ncurses" var stdscr: *c._win_st;
pub extern "ncurses" var ttytype: [*:0]const u8;
pub extern "ncurses" var COLORS: c_int;
pub extern "ncurses" var COLOR_PAIRS: c_int;
pub extern "ncurses" var COLS: c_int;
pub extern "ncurses" var ESCDELAY: c_int;
pub extern "ncurses" var LINES: c_int;
pub extern "ncurses" var TABSIZE: c_int;
pub extern "ncurses" var acs_map: []chtype;

pub const Window = struct {
    ptr: *c._win_st,

    //====================================================================
    // Globals
    //====================================================================

    pub fn cur() Window {
        return Window{ .ptr = curscr };
    }
    pub fn new() Window {
        return Window{ .ptr = newscr };
    }
    pub fn std() Window {
        return Window{ .ptr = stdscr };
    }
    pub fn ttytype() [*:0]const u8 {
        return ttytype;
    }
    pub fn colors() c_int {
        return COLORS;
    }
    pub fn colorPairs() c_int {
        return COLOR_PAIRS;
    }
    pub fn cols() c_int {
        return COLS;
    }
    pub fn escdelay() c_int {
        return ESCDELAY;
    }
    pub fn lines() c_int {
        return LINES;
    }
    pub fn tabsize() c_int {
        return TABSIZE;
    }

    //====================================================================
    // Initialization and manipulation
    //====================================================================

    pub fn initscr() Window {
        return Window{ .ptr = c.initscr() };
    }
    pub fn endwin() !void {
        if (c.endwin() == Err) return NcursesError.Generic;
    }
    pub fn newwin(nlines: c_int, ncols: c_int, begin_y: c_int, begin_x: c_int) !Window {
        const ptr = c.newwin(nlines, ncols, begin_y, begin_x);
        if (ptr == null) {
            return NcursesError.Generic;
        } else {
            return Window{ .ptr = ptr };
        }
    }
    pub fn delwin(self: Window) !void {
        if (c.delwin(self.ptr) == Err) return NcursesError.Generic;
    }
    pub fn mvwin(self: Window, y: c_int, x: c_int) !void {
        if (c.mvwin(self.ptr, y, x) == Err) return NcursesError.Generic;
    }
    pub fn subwin(self: Window, nlines: c_int, ncols: c_int, begin_y: c_int, begin_x: c_int) !Window {
        const ptr = c.subwin(self.ptr, nlines, ncols, begin_y, begin_x);
        if (ptr == null) {
            return NcursesError.Generic;
        } else {
            return Window{ .ptr = ptr };
        }
    }
    pub fn derwin(self: Window, nlines: c_int, ncols: c_int, begin_y: c_int, begin_x: c_int) !Window {
        const ptr = c.derwin(self.ptr, nlines, ncols, begin_y, begin_x);
        if (ptr == null) {
            return NcursesError.Generic;
        } else {
            return Window{ .ptr = ptr };
        }
    }
    pub fn mvderwin(self: Window, par_y: c_int, par_x: c_int) !void {
        if (c.mvderwin(self.ptr, par_y, par_x) == Err) return NcursesError.Generic;
    }
    pub fn dupwin(self: Window) !Window {
        const ptr = c.dupwin(self.ptr);
        if (ptr == null) {
            return NcursesError.Generic;
        } else {
            return Window{ .ptr = ptr };
        }
    }
    pub fn wsyncup(self: Window) void {
        c.wsyncaup(self.ptr);
    }
    pub fn syncok(self: Window, bf: bool) !void {
        if (c.syncok(self.ptr, bf) == Err) return NcursesError.Generic;
    }
    pub fn wcursyncup(self: Window) void {
        c.wcursyncup(self.ptr);
    }
    pub fn wsyncdown(self: Window) void {
        c.wsyncdown(self.ptr);
    }

    //====================================================================
    // Printing
    //====================================================================

    pub fn wprintw(self: Window, comptime format: [*:0]const u8, args: anytype) !void {
        if (@call(.{}, c.wprintw, .{ self.ptr, format } ++ args) == Err) return NcursesError.Generic;
    }
    pub fn mvwprintw(self: Window, y: c_int, x: c_int, comptime format: [*:0]const u8, args: anytype) !void {
        if (@call(.{}, c.mvwprintw, .{ self.ptr, y, x, format } ++ args) == Err) return NcursesError.Generic;
    }
    pub fn waddch(self: Window, ch: chtype) !void {
        if (c.waddch(self.ptr, ch) == Err) return NcursesError.Generic;
    }
    pub fn mvwaddch(self: Window, y: c_int, x: c_int, ch: chtype) !void {
        if (c.mvwaddch(self.ptr, y, x, ch) == Err) return NcursesError.Generic;
    }
    pub fn wechochar(self: Window, ch: chtype) !void {
        if (c.wechochar(self.ptr, ch) == Err) return NcursesError.Generic;
    }

    //====================================================================
    // Input
    //====================================================================

    pub fn wgetch(self: Window) !c_int {
        const result = c.wgetch(self.ptr);
        if (result == Err) return NcursesError.Generic;

        return result;
    }
    pub fn mvwgetch(self: Window, y: c_int, x: c_int) !c_int {
        const result = c.mvwgetch(self.ptr, y, x);
        if (result == Err) return NcursesError.Generic;

        return result;
    }
    pub fn wscanw(self: Window, comptime format: [*:0]const u8, args: anytype) !c_int {
        const result = @call(.{}, c.wprintw, .{ self.ptr, format } ++ args);
        if (result == Err) {
            return NcursesError.Generic;
        } else {
            return result;
        }
    }
    pub fn mvwscanw(self: Window, y: c_int, x: c_int, comptime format: [*:0]const u8, args: anytype) !c_int {
        const result = @call(.{}, c.wprintw, .{ self.ptr, y, x, format } ++ args);
        if (result == Err) {
            return NcursesError.Generic;
        } else {
            return result;
        }
    }
    pub fn wgetstr(self: Window, str: [*:0]u8) !void {
        if (c.wgetstr(self.ptr, str) == Err) return NcursesError.Generic;
    }
    pub fn wgetnstr(self: Window, str: [*:0]u8, n: c_int) !void {
        if (c.wgetstr(self.ptr, str, n) == Err) return NcursesError.Generic;
    }
    pub fn mvwgetstr(self: Window, y: c_int, x: c_int, str: [*:0]u8) !void {
        if (c.mvwgetstr(self.ptr, y, x, str) == Err) return NcursesError.Generic;
    }
    pub fn mvwgetnstr(self: Window, y: c_int, x: c_int, str: [*:0]u8, n: c_int) !void {
        if (c.mvwgetnstr(self.ptr, y, x, str, n) == Err) return NcursesError.Generic;
    }

    //====================================================================
    // Character and window attribute control
    //====================================================================

    pub fn wattr_get(self: Window, attrs: *attr_t, pair: *c_short, opts: *c_void) !void {
        if (c.wattr_get(self.ptr, attrs, pair, opts) == Err) return NcursesError.Generic;
    }
    pub fn wattr_set(self: Window, attrs: attr_t, pair: c_short, opts: *c_void) !void {
        if (c.wattr_set(self.ptr, attrs, pair, opts) == Err) return NcursesError.Generic;
    }
    pub fn wattr_off(self: Window, attrs: attr_t, opts: *c_void) !void {
        if (c.wattr_off(self.ptr, attrs, opts) == Err) return NcursesError.Generic;
    }
    pub fn wattr_on(self: Window, attrs: attr_t, opts: *c_void) !void {
        if (c.wattr_on(self.ptr, attrs, opts) == Err) return NcursesError.Generic;
    }
    pub fn wattroff(self: Window, attrs: c_int) !void {
        if (c.wattroff(self.ptr, attrs) == Err) return NcursesError.Generic;
    }
    pub fn wattron(self: Window, attrs: c_int) !void {
        if (c.wattron(self.ptr, attrs) == Err) return NcursesError.Generic;
    }
    pub fn wattrset(self: Window, attrs: c_int) !void {
        if (c.wattrset(self.ptr, attrs) == Err) return NcursesError.Generic;
    }
    pub fn wchgat(self: Window, n: c_int, attr: attr_t, pair: c_short, opts: ?*const c_void) !void {
        if (c.wchgat(self.ptr, n, attr, pair, opts) == Err) return NcursesError.Generic;
    }
    pub fn mvwchgat(self: Window, y: c_int, x: c_int, n: c_int, attr: attr_t, pair: c_short, opts: ?*const c_void) !void {
        if (c.mvwchgat(self.ptr, y, x, n, attr, pair, opts) == Err) return NcursesError.Generic;
    }

    //====================================================================
    // Refresh windows and lines
    //====================================================================

    pub fn wrefresh(self: Window) !void {
        if (c.wrefresh(self.ptr) == Err) return NcursesError.Generic;
    }
    pub fn wnoutrefresh(self: Window) !void {
        if (c.wnoutrefresh(self.ptr) == Err) return NcursesError.Generic;
    }
    pub fn redrawwin(self: Window) !void {
        if (c.redrawwin(self.ptr) == Err) return NcursesError.Generic;
    }
    pub fn wredrawln(self: Window, beg_line: c_int, num_lines: c_int) !void {
        if (c.wredrawln(self.ptr, beg_line, num_lines) == Err) return NcursesError.Generic;
    }

    //====================================================================
    // Coordinates
    //====================================================================

    pub fn getyx(self: Window, y: *c_int, x: *c_int) void {
        y.* = getcury(self);
        x.* = getcurx(self);
    }
    pub inline fn getcury(self: Window) c_int {
        return c.getcury(self.ptr);
    }
    pub inline fn getcurx(self: Window) c_int {
        return c.getcurx(self.ptr);
    }
    pub fn getbegyx(self: Window, y: *c_int, x: *c_int) void {
        y.* = getbegy(self);
        x.* = getbegx(self);
    }
    pub inline fn getbegy(self: Window) c_int {
        return c.getbegy(self.ptr);
    }
    pub inline fn getbegx(self: Window) c_int {
        return c.getbegx(self.ptr);
    }
    pub fn getmaxyx(self: Window, y: *c_int, x: *c_int) void {
        y.* = getmaxy(self);
        x.* = getmaxx(self);
    }
    pub inline fn getmaxy(self: Window) c_int {
        return c.getmaxy(self.ptr);
    }
    pub inline fn getmaxx(self: Window) c_int {
        return c.getmaxx(self.ptr);
    }
    pub fn getparyx(self: Window, y: *c_int, x: *c_int) void {
        y.* = getpary(self);
        x.* = getparx(self);
    }
    pub inline fn getpary(self: Window) c_int {
        return c.getpary(self.ptr);
    }
    pub inline fn getparx(self: Window) c_int {
        return c.getparx(self.ptr);
    }

    //====================================================================
    // Movement
    //====================================================================

    pub fn wmove(self: Window, y: c_int, x: c_int) !void {
        if (c.wmove(self.ptr, y, x) == Err) return NcursesError.Generic;
    }

    //====================================================================
    // Borders, lines
    //====================================================================

    pub fn wborder(self: Window, ls: chtype, rs: chtype, ts: chtype, bs: chtype, tl: chtype, tr: chtype, bl: chtype, br: chtype) !void {
        if (c.wborder(self.ptr, ls, rs, ts, bs, tl, tr, bl, br) == Err) return NcursesError.Generic;
    }
    pub fn box(self: Window, verch: chtype, horch: chtype) !void {
        if (c.box(self.ptr, verch, horch) == Err) return NcursesError.Generic;
    }
    pub fn whline(self: Window, ch: chtype, n: c_int) !void {
        if (c.whline(self.ptr, ch, n) == Err) return NcursesError.Generic;
    }
    pub fn wvline(self: Window, ch: chtype, n: c_int) !void {
        if (c.wvline(self.ptr, ch, n) == Err) return NcursesError.Generic;
    }
    pub fn mvwhline(self: Window, y: c_int, x: c_int, ch: chtype, n: c_int) !void {
        if (c.mvwhline(self.ptr, ch, n) == Err) return NcursesError.Generic;
    }
    pub fn mvwvline(self: Window, y: c_int, x: c_int, ch: chtype, n: c_int) !void {
        if (c.mvwvline(self.ptr, ch, n) == Err) return NcursesError.Generic;
    }
};

//====================================================================
// Printing
//====================================================================

pub inline fn printw(comptime format: [*:0]const u8, args: anytype) !void {
    return try Window.std().wprintw(format, args);
}
pub inline fn mvprintw(y: c_int, x: c_int, comptime format: [*:0]const u8, args: anytype) !void {
    return try Window.std().mvwprintw(y, x, format, args);
}
pub inline fn addch(ch: chtype) !void {
    return try Window.std().waddch(ch);
}
pub inline fn mvaddch(y: c_int, x: c_int, ch: chtype) !void {
    return try Window.std().mvwaddch(y, x, ch);
}
pub inline fn echochar(ch: chtype) !void {
    return try Window.std().wechochar(ch);
}

//====================================================================
// Input
//====================================================================

pub inline fn getch() !c_int {
    return try Window.std().wgetch();
}
pub inline fn mvgetch(y: c_int, x: c_int) !c_int {
    return try Window.std().mvwgetch(y, x);
}
pub fn ungetch(ch: c_int) !void {
    if (c.ungetch(ch) == Err) return NcursesError.Generic;
}
pub fn has_key(ch: c_int) bool {
    return c.has_key(ch) == True;
}
pub inline fn scanw(comptime format: [*:0]const u8, args: anytype) !c_int {
    return try Window.std().wscanw(format, args);
}
pub inline fn mvscanw(y: c_int, x: c_int, comptime format: [*:0]const u8, args: anytype) !c_int {
    return try Window.std().mvwscanw(format, args);
}
pub inline fn getstr(str: [*:0]u8) !void {
    return try Window.std().wgetstr(str);
}
pub inline fn getnstr(str: [*:0]u8, n: c_int) !void {
    return try Window.std().wgetnstr(str, n);
}
pub inline fn mvgetstr(y: c_int, x: c_int, str: [*:0]u8) !void {
    return try Window.std().mvwgetstr(y, x, str);
}
pub inline fn mvgetnstr(y: c_int, x: c_int, str: [*:0]u8, n: c_int) !void {
    return try Window.std().mvwgetnstr(y, x, str, n);
}

//====================================================================
// Input options
//====================================================================

pub fn cbreak() !void {
    if (c.cbreak() == Err) return NcursesError.Generic;
}
pub fn nocbreak() !void {
    if (c.nocbreak() == Err) return NcursesError.Generic;
}
pub fn echo() !void {
    if (c.echo() == Err) return NcursesError.Generic;
}
pub fn noecho() !void {
    if (c.noecho() == Err) return NcursesError.Generic;
}
pub fn raw() !void {
    if (c.raw() == Err) return NcursesError.Generic;
}
pub fn noraw() !void {
    if (c.noraw() == Err) return NcursesError.Generic;
}
pub fn keypad(self: Window, bf: bool) !void {
    if (c.keypad(self.ptr, bf) == Err) return NcursesError.Generic;
}

//====================================================================
// Character and window attribute control
//====================================================================

pub inline fn attr_get(attrs: *attr_t, pair: *c_short, opts: *c_void) !void {
    return try Window.std().wattr_get(attrs, pair, opts);
}
pub inline fn attr_set(attrs: attr_t, pair: c_short, opts: *c_void) !void {
    return try Window.std().wattr_set(attrs, pair, opts);
}
pub inline fn attr_off(attrs: attr_t, opts: *c_void) !void {
    return try Window.std().wattr_off(attrs, opts);
}
pub inline fn attr_on(attrs: attr_t, opts: *c_void) !void {
    return try Window.std().wattr_on(attrs, opts);
}
pub inline fn attroff(attrs: c_int) !void {
    return try Window.std().wattroff(attrs);
}
pub inline fn attron(attrs: c_int) !void {
    return try Window.std().wattron(attrs);
}
pub inline fn attrset(attrs: c_int) !void {
    return try Window.std().wattrset(attrs);
}
pub inline fn chgat(n: c_int, attr: attr_t, pair: c_short, opts: ?*const c_void) !void {
    return try Window.std().wchgat(n, attr, pair, opts);
}
pub inline fn mvchgat(y: c_int, x: c_int, n: c_int, attr: attr_t, pair: c_short, opts: ?*const c_void) !void {
    return try Window.std().mvwchgat(y, x, n, attr, pair, opts);
}

//====================================================================
// Refresh windows and lines
//====================================================================

pub inline fn refresh() !void {
    return try Window.std().wrefresh();
}
pub fn doupdate() !void {
    if (c.doupdate() == Err) return NcursesError.Generic;
}

//====================================================================
// Movement
//====================================================================

pub inline fn move(y: c_int, x: c_int) !void {
    return try Window.std().wmove(y, x);
}

//====================================================================
// Borders, lines
//====================================================================

pub inline fn border(ls: chtype, rs: chtype, ts: chtype, bs: chtype, tl: chtype, tr: chtype, bl: chtype, br: chtype) !void {
    return try Window.std().wborder(self.ptr, ls, rs, ts, bs, tl, tr, bl, br);
}
pub inline fn hline(ch: chtype, n: c_int) !void {
    return try Window.std().whline(self.ptr, ch, n);
}
pub inline fn vline(ch: chtype, n: c_int) !void {
    return try Window.std().wvline(self.ptr, ch, n);
}
pub inline fn mvhline(y: c_int, x: c_int, ch: chtype, n: c_int) !void {
    return try Window.std().mvwhline(self.ptr, ch, n);
}
pub inline fn mvvline(y: c_int, x: c_int, ch: chtype, n: c_int) !void {
    return try Window.std().mvwvline(self.ptr, ch, n);
}

//====================================================================
// Colors
//====================================================================

pub fn start_color() !void {
    if (c.start_color() == Err) return NcursesError.Generic;
}
pub fn has_colors() bool {
    return c.has_colors();
}
pub fn can_change_color() bool {
    return c.can_change_color();
}
pub fn init_pair(pair: c_short, f: c_short, b: c_short) !void {
    if (c.init_pair(pair, f, b) == Err) return NcursesError.Generic;
}
pub fn init_color(color: c_short, r: c_short, g: c_short, b: c_short) !void {
    if (c.init_color(color, r, g, b) == Err) return NcursesError.Generic;
}
pub fn init_extended_pair(pair: c_int, f: c_int, b: c_int) !void {
    if (c.init_pair(pair, f, b) == Err) return NcursesError.Generic;
}
pub fn init_extended_color(color: c_int, r: c_int, g: c_int, b: c_int) !void {
    if (c.init_color(color, r, g, b) == Err) return NcursesError.Generic;
}
pub fn pair_content(pair: c_short, f: *c_short, b: *c_short) !void {
    if (c.color_content(pair, f, b) == Err) return NcursesError.Generic;
}
pub fn color_content(color: c_short, r: *c_short, g: *c_short, b: *c_short) !void {
    if (c.color_content(color, r, g, b) == Err) return NcursesError.Generic;
}
pub fn extended_pair_content(pair: c_int, f: *c_int, b: *c_int) !void {
    if (c.color_content(pair, f, b) == Err) return NcursesError.Generic;
}
pub fn extended_color_content(color: c_int, r: *c_int, g: *c_int, b: *c_int) !void {
    if (c.color_content(color, r, g, b) == Err) return NcursesError.Generic;
}
pub fn reset_color_pairs() void {
    c.reset_color_pairs();
}
pub fn pair_number(attrs: c_int) c_int {
    return @intCast(
        c_int,
        ((@intCast(c_ulong, attrs) & @enumToInt(Attribute.color)) >> Attribute.default_shift),
    );
}
pub fn color_pair(n: c_int) c_int {
    return Attribute.ncursesBits(n, 0) & @enumToInt(Attribute.color);
}
